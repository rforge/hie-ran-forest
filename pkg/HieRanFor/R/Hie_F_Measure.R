
# function, takes as input a confusion matrix, the unique_Path data frame and beta_H_F (weight of hierarchical precision relative to hierarchial recall when calcaultaing the hierarhcial F measure) and return the hierarchical precision, hierarchical recall and hierrarchaocla F measure

Hie_F_Measure = function(Conf_Matr,       # Object of class confusion matrix, as generated by confusionMatrix of the caret package
                         Unique_Path,     # Data frame, the Unique_Path data frame from Run_HRF
                         Beta_H_F = 1,    # Numeric in the range 0 < Beta_H_F 
                         By_Node=FALSE,   # Logical, if FALSE, the Hierarfchial precision, recall and F measure are estimated only for the entire confusion table. If TRUE, the measures ere estimated for each node as well. 
                         ...)
{ # Start function
  
 
  
  # Perform some checks
  if(!is.numeric(Beta_H_F))
  {cat(paste("\n", "Beta_H_F should be numeric. Defalut value of Beta_H_F = 1 is used","\n",sep=""))
   Beta_H_F <- 1}
  
  if(Beta_H_F<0)
  {cat(paste("\n", "Beta_H_F should be larger than 0. Defalut value of Beta_H_F = 1 is used","\n",sep=""))
   Beta_H_F <- 1}
  
  if(class(Conf_Matr)!="confusionMatrix")
  {stop(paste("\n","Conf_Matr should be of class", "\n",sep=""))}
  
  if(!is.logical(By_Node))
  {cat(paste("\n", "By_Node should be logical. Defalut value of By_Node=FALSE is used","\n",sep=""))
   By_Node=FALSE}
  
  
  
  ###############################################
  ### extract info from the confusion matrix  ###
  ##_##_##_##_##_##_##_##_##_##_##_##_##_##_##_##
  
  Conf_Matr_Table     <- Conf_Matr$table                   # the confusion table
  
  Conf_Matr_J_Sums  <- colSums(Conf_Matr_Table)   # The number of cases observed in each node
  Conf_Matr_K_Sums  <- rowSums(Conf_Matr_Table)   # the number of cases classifed as each node
  Conf_Matr_J_Names <- colnames(Conf_Matr_Table)         # The names of the nodes in the columns
  Conf_Matr_K_Names <- rownames(Conf_Matr_Table)         # the name of the nodes in the rows
  Self_J <- as.data.frame(cbind(Conf_Matr_J_Names,Conf_Matr_J_Sums))
  Self_K <- as.data.frame(cbind(Conf_Matr_K_Names,Conf_Matr_K_Sums))
  
  Self_J$Depth <- NA
  Self_K$Depth <- NA
  colnames(Self_J)[1] <-  "Node_Name"
  colnames(Self_J)[2] <-  "Node_Freq"
  colnames(Self_K)[1] <-  "Node_Name"
  colnames(Self_K)[2] <-  "Node_Freq"
  Self_J[,2] <- as.numeric(as.character(Self_J[,2]))
  Self_K[,2] <- as.numeric(as.character(Self_K[,2]))
  
  
  # check if the nodes in the rows and columns are the same and in the same order
  if(!all(Conf_Matr_J_Names==Conf_Matr_K_Names))
  {stop(paste("\n"," the names of the rows and columns in the confusion matrix do not match", "\n",sep=""))}
  
  ###############################################
  ### Estimate the Shared_Nodes matrix        ###
  ##_##_##_##_##_##_##_##_##_##_##_##_##_##_##_##
  
  
  Shared_Nodes <- Num_Shared_Nodes(Unique_Path = Unique_Path,
                                   Ordered_Term_Node = colnames(Conf_Matr_Table))
  
  if(!all(colnames(Shared_Nodes)==colnames(Conf_Matr_Table)) || !all(rownames(Shared_Nodes)==rownames(Conf_Matr_Table)))
  {stop(paste("\n","Cannot match the names of the Conf_Matr with terminal nodes in Unique_Path","\n",sep=""))}
  
  
  
  
  ###############################################
  ### Arrange the return data frame           ###
  ##_##_##_##_##_##_##_##_##_##_##_##_##_##_##_##
  
  
  Hie_F_Results <-data.frame(Measure     = c(NA),
                             Values      = c(NA))
  
  
  Hie_F_Results[1,1] <- "H_Precision"
  Hie_F_Results[2,1] <- "H_ReCall"
  Hie_F_Results[3,1] <- "H_F_Measure" 
  
  if(By_Node)
  {
    #Nodes_H_Acc_Ind <- c("N_H_Precision","N_H_ReCall","N_H_F_Measure")
    Nodes_H_Measures                 <- expand.grid(colnames(Conf_Matr_Table),c("N_H_Precision","N_H_ReCall","N_H_F_Measure"))
    colnames(Nodes_H_Measures)       <- c("Term_Node","Index")
    Nodes_H_Measures$Measure <- paste(Nodes_H_Measures$Term_Node,
                                      Nodes_H_Measures$Index,
                                      sep=";")
    Nodes_H_Measures$Values <- NA
    
   
    Hie_F_Results = rbind(Hie_F_Results,Nodes_H_Measures[,c(3,4)])
    #rm(Nodes_H_Measures)
  }
  
  
  ###############################################
  ### Calcualte hP, hR and hF                 ###
  ##_##_##_##_##_##_##_##_##_##_##_##_##_##_##_##
  
  # multiply element by element the confusion matrix and the sahred nodes matrix
  Matrix_Fre_Shared <- Conf_Matr_Table*Shared_Nodes
  
  
  
  
  for (count_Nodes in 1:nrow(Self_J))
  {
    Num_Col_run <- match(Self_J[count_Nodes,"Node_Name"],colnames(Shared_Nodes))
    
    Self_J[count_Nodes,"Depth"] <- Shared_Nodes[Num_Col_run,Num_Col_run]
    Self_K[count_Nodes,"Depth"] <- Shared_Nodes[Num_Col_run,Num_Col_run]
  }
  
    
  Self_J[,"F_j_all_times_S_j_j"] <- Self_J[,2] * Self_J[,3]
  Self_K[,"F_all_k_times_S_k_k"] <- Self_K[,2] * Self_K[,3]
  
  Sum_K_J <- sum(Matrix_Fre_Shared)  # the numerator of the hP and hR
  Sum_K   <- sum(Self_K[,"F_all_k_times_S_k_k"]) 
  Sum_J   <- sum(Self_J[,"F_j_all_times_S_j_j"]) 
  
  hP <- Sum_K_J/Sum_K
  hR <- Sum_K_J/Sum_J
  hF <- ((Beta_H_F*Beta_H_F+1)*hP*hR)/(Beta_H_F*Beta_H_F*hP + hR)
    
  Hie_F_Results[1,2] <- hP
  Hie_F_Results[2,2] <- hR
  Hie_F_Results[3,2] <- hF 
  
  if(By_Node)
  {
    for (count_node in 1: nrow(Conf_Matr_Table))
    {
      Focal_Node <- colnames(Conf_Matr_Table)[count_node]
      Shared_Row <- match(Focal_Node,rownames(Matrix_Fre_Shared))
      Shared_Col <- match(Focal_Node,colnames(Matrix_Fre_Shared))
      
      Node_Sum_Shared_Predicted <- sum(Matrix_Fre_Shared[Shared_Row,])  
      Node_Sum_Predicted        <- Self_K[Shared_Row,"F_all_k_times_S_k_k"]
        
      Node_Sum_Shared_Observed  <- sum(Matrix_Fre_Shared[,Shared_Col]) 
      Node_Sum_Observed         <- Self_J[Shared_Col,"F_j_all_times_S_j_j"]
      
      NhP <- Node_Sum_Shared_Predicted / Node_Sum_Predicted
      NhR <- Node_Sum_Shared_Observed  / Node_Sum_Observed
      NhF <- ((Beta_H_F*Beta_H_F+1)*NhP*NhR)/(Beta_H_F*Beta_H_F*NhP + NhR)
      
      Node_Prec <- paste(Focal_Node,
                         "N_H_Precision",
                         sep=";")
      
      Node_ReCa <- paste(Focal_Node,
                         "N_H_ReCall",
                         sep=";")
      
      Node_F    <- paste(Focal_Node,
                         "N_H_F_Measure",
                         sep=";")
      
      Hie_F_Results[match(Node_Prec,Hie_F_Results$Measure),2] <- NhP 
      Hie_F_Results[match(Node_ReCa,Hie_F_Results$Measure),2] <- NhR
      Hie_F_Results[match(Node_F,Hie_F_Results$Measure)   ,2] <- NhF
      
    }
    
  }
    
    
  Hie_F_Results
} # End function