% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/PredictNewHRF.R
\name{PredictNewHRF}
\alias{PredictNewHRF}
\title{Predict crisp class for \code{new.data}}
\usage{
PredictNewHRF(hie.RF, new.data, new.data.case.ID = 1,
  new.data.exp.var = c(2:ncol(new.data)),
  crisp.rule = c("multiplicative.majority", "multiplicative.permutation",
  "stepwise.majority"), perm.num = 500, div.logical = TRUE,
  div.print = 25, ...)
}
\arguments{
\item{hie.RF}{Object of class \code{"HRF"} - the output of
  \code{RunHRF}.}

\item{new.data}{Data frame containing additional cases that were
  note a part of the original training set.}

\item{new.data.case.ID}{Integer, specifying the column number with the
  \code{case.ID} in the \code{new.data} data frame. The \code{case.ID} values
  should be unique and different from those in the training data.}

\item{new.data.exp.var}{Vector of integers, specifying the columns of
  \code{new.data} that contains the same set of explanatory variables as used
  in the training of \code{hie.RF}.}

\item{crisp.rule}{The method of selecting a single crisp class from
  the proportion of votes. See details in \code{\link{PerformanceHRF}}.}

\item{perm.num}{Integer, number of random permutations for each
  case if \code{'multiplicative.permutation'} is applied.}

\item{div.logical}{Logical, if \code{TRUE} progress when
  \code{'multiplicative.permutation'} is applied will be printed every
  \code{div.print} permutations.}

\item{div.print}{See above.}

\item{\dots}{Optional parameters to be passed to low level functions.}
}
\value{
A list with the following components:
   {\tabular{lll}{
     \code{"raw.vote"}              \tab \tab Data frame containing for each
     case, the proportion of votes for each node in each local classifier
     (the output of \code{\link{predict.HRF}}). \cr

     \code{"crisp.case.class"}      \tab \tab Data frame containing the crisp
     class for each case based on all options defined by
     \code{crisp.rule}.\cr

     \code{"multiplicative.prop"}   \tab \tab Optional data frame with the
     multiplicative proportion of votes (the output of
     \code{\link{GetMultPropVotes}}). Will be returned if
     \code{"multiplicative.majority"} or \code{"multiplicative.permutation"}
     were selected.\cr

     \code{"call"}                  \tab \tab The call to function
     \code{PredictNewHRF}. \cr

   }}
}
\description{
This function takes as input a \code{new.data} data frame with the same
explanatory variables as those used in \code{hie.RF}. Next, the
\code{\link{predict.HRF}} function is applied to extract the proportion of
votes that each case in \code{new.data} received for each node in each local
classifier. Finally, up to three methods of selecting a single terminal node
(as given by \code{crisp.rule} and described in \code{\link{PerformanceHRF}})
are applied for each case.
}
\details{
If the observed class of \code{new.data} are known, the function
  \code{\link{PerformanceNewHRF}} will perform all the steps in this function
  and will add the estimation of performance measures.\cr Inherited from
  \code{\link{randomForest}}, predictions for \code{new.data} cannot be made
  if the \code{new.data} contains factor levels (both for classes and for
  categorical explanatory variables) that were not represented in the
  training data. Before running \code{RunHRF} we recommend either sub-setting
  the training and new data from one general data frame or running the
  \code{\link{JoinLevels}} function on each categorical variable.
}
\examples{
# create a random HRF dataset and RunHRF
set.seed(354)
random.hRF <- RandomHRF(num.term.nodes = 20, tree.depth = 4)
train.data <- random.hRF$train.data
new.data   <- random.hRF$new.data
hie.RF.random <- RunHRF(train.data = train.data,
                        case.ID    = "case.ID",
                        hie.levels = c(2:(random.hRF$call$tree.depth + 1)))

# predict for new.data
pred.new.hRF <- PredictNewHRF(hie.RF     = hie.RF.random,
                              new.data   = new.data,
                              crisp.rule = c("stepwise.majority",
                                             "multiplicative.majority" ,
                                             "multiplicative.permutation"),
                              perm.num   = 10,
                              div.print  = 2)

# extract values
names(pred.new.hRF)
pred.new.votes       <- pred.new.hRF$raw.votes
pred.new.mult.prop   <- pred.new.hRF$multiplicative.prop
pred.new.crisp.class <- pred.new.hRF$crisp.case.class
pred.new.call        <- pred.new.hRF$call
}
\author{
Yoni Gavish <gavishyoni@gmail.com>
}
\seealso{
\code{\link{RunHRF}} for running a hierarchical randomForest analysis,
\code{\link{PerformanceHRF}} for performance analysis,
\code{\link{PerformanceNewHRF}} for performance analysis on \code{new.data}
with observed terminal node,
}

